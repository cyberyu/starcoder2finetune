<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FIM Dataset Viewer - Single File</title>
  <style>
    body { 
      background: #f5f5f5; 
      color: #222; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      line-height: 1.6; 
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
    .upload-section { 
      background: #fff; 
      padding: 20px; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      margin-bottom: 20px; 
    }
    .stats-section { 
      background: #fff; 
      padding: 15px; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      margin-bottom: 20px; 
      display: flex; 
      gap: 20px; 
      flex-wrap: wrap; 
    }
    .stat-item { flex: 1; min-width: 150px; text-align: center; }
    .stat-value { font-size: 2em; font-weight: bold; color: #2196F3; }
    .stat-label { font-size: 0.9em; color: #666; text-transform: uppercase; }
    .fim-card { 
      background: #fff; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      margin-bottom: 20px; 
      overflow: hidden; 
    }
    .fim-header { 
      background: #2196F3; 
      color: white; 
      padding: 15px; 
      font-weight: bold; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
    }
    .fim-section { margin: 15px; }
    .fim-section-title { 
      font-weight: bold; 
      color: #333; 
      margin-bottom: 8px; 
      padding: 8px; 
      background: #f8f9fa; 
      border-left: 4px solid #2196F3; 
    }
    .fim-content { 
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
      background: #2d2d2d; 
      color: #f8f8f2; 
      padding: 15px; 
      border-radius: 6px; 
      white-space: pre-wrap; 
      word-wrap: break-word; 
      max-height: 300px; 
      overflow-y: auto; 
      font-size: 14px; 
      line-height: 1.4; 
    }
    .fim-prefix { border-left: 4px solid #4CAF50; }
    .fim-middle { border-left: 4px solid #FF9800; }
    .fim-suffix { border-left: 4px solid #9C27B0; }
    button { 
      background: #2196F3; 
      color: white; 
      border: none; 
      padding: 12px 24px; 
      border-radius: 6px; 
      cursor: pointer; 
      font-size: 1rem; 
      transition: background-color 0.3s; 
    }
    button:hover { background: #1976D2; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    input[type="file"] { 
      margin: 10px 0; 
      padding: 8px; 
      border: 2px dashed #ddd; 
      border-radius: 6px; 
      background: #fafafa; 
    }
    .error { 
      color: #f44336; 
      background: #ffebee; 
      padding: 12px; 
      border-radius: 6px; 
      margin: 10px 0; 
    }
    .navigation { 
      display: flex; 
      gap: 10px; 
      align-items: center; 
    }
    .page-info { color: #666; font-size: 0.9em; }
    .search-section { 
      background: #fff; 
      padding: 15px; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      margin-bottom: 20px; 
    }
    .search-input { 
      width: 100%; 
      padding: 10px; 
      border: 1px solid #ddd; 
      border-radius: 6px; 
      font-size: 1rem; 
      box-sizing: border-box;
    }
    .hidden { display: none; }
    .quality-section { 
      background: #f8f9fa; 
      padding: 15px; 
      border-radius: 6px; 
      margin: 15px; 
      border: 1px solid #e9ecef; 
    }
    .quality-scores { 
      display: flex; 
      gap: 15px; 
      flex-wrap: wrap; 
      margin-top: 10px; 
    }
    .quality-score { 
      background: #fff; 
      padding: 8px 12px; 
      border-radius: 4px; 
      border: 1px solid #dee2e6; 
      font-size: 0.9em; 
    }
    .quality-score.high { border-left: 4px solid #28a745; }
    .quality-score.medium { border-left: 4px solid #ffc107; }
    .quality-score.low { border-left: 4px solid #dc3545; }
    .quality-score-label { font-weight: bold; color: #495057; }
    .quality-score-value { color: #6c757d; }
    .quality-badge { 
      display: inline-block; 
      padding: 2px 8px; 
      border-radius: 12px; 
      font-size: 0.8em; 
      font-weight: bold; 
      margin-left: 8px; 
    }
    .quality-badge.high { background: #d4edda; color: #155724; }
    .quality-badge.medium { background: #fff3cd; color: #856404; }
    .quality-badge.low { background: #f8d7da; color: #721c24; }
  </style>
</head>
<body>
  <div class="container">
    <h1 style="text-align: center; color: #2196F3; margin-bottom: 30px;">
      üîç FIM Dataset Viewer
    </h1>
    
    <div class="upload-section">
      <h3>Upload JSONL File</h3>
      <input type="file" id="fileInput" accept=".jsonl,.json" />
      <br />
      <button onclick="loadDataset()">Load Dataset</button>
      <div id="error" class="error hidden"></div>
    </div>

    <div id="statsSection" class="stats-section hidden">
      <!-- Stats will be populated here -->
    </div>
    
    <div id="searchSection" class="search-section hidden">
      <h3>Search Tasks</h3>
      <input
        type="text"
        class="search-input"
        id="searchInput"
        placeholder="Search in prefix, middle, suffix, output, or quality scores (e.g. 'quality:0.8')..."
      />
      <div id="searchResults" style="margin-top: 10px; color: #666;"></div>
    </div>

    <div id="navigationInfo" style="text-align: center; margin-bottom: 20px; color: #666;" class="hidden">
      Use ‚Üê ‚Üí arrow keys or buttons to navigate
    </div>

    <div id="fimCard" class="hidden">
      <!-- FIM card will be populated here -->
    </div>

    <div id="noResults" style="text-align: center; padding: 40px; color: #666;" class="hidden">
      No tasks match your search criteria.
    </div>
  </div>

  <script>
    // Global variables
    let allData = [];
    let filteredData = [];
    let currentIndex = 0;
    let totalRowsInFile = 0;

    // Extract FIM components from content
    function extractFIMComponents(content) {
      if (!content) return { prefix: '', middle: '', suffix: '' };
      
      // Handle both <fim_prefix> and <fim-prefix> formats
      const prefixPatterns = ['<fim_prefix>', '<fim-prefix>'];
      const middlePatterns = ['<fim_middle>', '<fim-middle>'];
      const suffixPatterns = ['<fim_suffix>', '<fim-suffix>'];
      
      let prefixStart = -1, prefixEnd = -1;
      let suffixStart = -1, suffixEnd = -1;
      let middleStart = -1;
      
      // Find prefix
      for (const pattern of prefixPatterns) {
        const idx = content.indexOf(pattern);
        if (idx !== -1) {
          prefixStart = idx + pattern.length;
          break;
        }
      }
      
      // Find suffix
      for (const pattern of suffixPatterns) {
        const idx = content.indexOf(pattern);
        if (idx !== -1) {
          prefixEnd = idx;
          suffixStart = idx + pattern.length;
          break;
        }
      }
      
      // Find middle
      for (const pattern of middlePatterns) {
        const idx = content.indexOf(pattern);
        if (idx !== -1) {
          suffixEnd = idx;
          middleStart = idx + pattern.length;
          break;
        }
      }
      
      // Extract the actual content
      const prefix = (prefixStart !== -1 && prefixEnd !== -1) ? content.substring(prefixStart, prefixEnd).trim() : '';
      const suffix = (suffixStart !== -1 && suffixEnd !== -1) ? content.substring(suffixStart, suffixEnd).trim() : '';
      const middle = middleStart !== -1 ? content.substring(middleStart).trim() : '';
      
      return { prefix, middle, suffix };
    }

    // Extract quality scores from task data
    function extractQualityScores(task) {
      const scores = {};
      
      // Check for the new quality_scores structure
      if (task.quality_scores) {
        const qs = task.quality_scores;
        
        // Phase 1: Context Quality Score
        if (qs.phase1_context_quality !== undefined) {
          scores.context = qs.phase1_context_quality;
        }
        
        // Phase 2: Middle Content Quality Score
        if (qs.phase2_middle_quality !== undefined) {
          scores.middle = qs.phase2_middle_quality;
        }
        
        // Phase 3: Length-based Quality Score
        if (qs.phase3_length_quality !== undefined) {
          scores.length = qs.phase3_length_quality;
        }
        
        // Composite/Comprehensive Quality Score
        if (qs.composite_quality !== undefined) {
          scores.comprehensive = qs.composite_quality;
        }
      }
      
      // Check for quality_metrics structure
      if (task.quality_metrics) {
        const qm = task.quality_metrics;
        
        if (qm.prefix_length !== undefined) {
          scores.prefixLength = qm.prefix_length;
        }
        if (qm.middle_length !== undefined) {
          scores.middleLength = qm.middle_length;
        }
        if (qm.ratio !== undefined) {
          scores.ratio = qm.ratio;
        }
      }
      
      // Check for quality_tier
      if (task.quality_tier !== undefined) {
        scores.tier = task.quality_tier;
      }
      
      // Fallback: Check for old structure (backward compatibility)
      if (task.quality_score !== undefined) {
        scores.context = task.quality_score;
      }
      if (task.quality_middle_score !== undefined) {
        scores.middle = task.quality_middle_score;
      }
      if (task.quality_length_score !== undefined) {
        scores.length = task.quality_length_score;
      }
      if (task.comprehensive_quality_score !== undefined) {
        scores.comprehensive = task.comprehensive_quality_score;
      }
      if (task.quality_prefix_length !== undefined) {
        scores.prefixLength = task.quality_prefix_length;
      }
      if (task.quality_middle_length !== undefined) {
        scores.middleLength = task.quality_middle_length;
      }
      if (task.quality_ratio !== undefined) {
        scores.ratio = task.quality_ratio;
      }
      
      return scores;
    }

    // Get quality level for styling
    function getQualityLevel(score) {
      if (score >= 0.8) return 'high';
      if (score >= 0.6) return 'medium';
      return 'low';
    }

    // Format quality score display
    function formatQualityScore(score, label) {
      if (score === undefined || score === null) return null;
      
      const level = getQualityLevel(score);
      const formattedScore = typeof score === 'number' ? score.toFixed(3) : score;
      
      return `
        <div class="quality-score ${level}">
          <span class="quality-score-label">${label}:</span>
          <span class="quality-score-value">${formattedScore}</span>
        </div>
      `;
    }

    // Parse JSONL file with memory-safe chunked reading
    function parseJSONL(text, maxLines = 1000) {
      const lines = text.split(/\r?\n/);
      const totalLines = lines.length;
      
      // Only process up to maxLines to prevent memory issues
      const linesToProcess = Math.min(totalLines, maxLines);
      const processedLines = [];
      
      for (let i = 0; i < linesToProcess; i++) {
        const line = lines[i].trim();
        if (line && !line.startsWith('//')) {
          try {
            const parsed = JSON.parse(line);
            if (parsed) {
              processedLines.push(parsed);
            }
          } catch (e) {
            // Skip invalid JSON lines
            continue;
          }
        }
      }
      
      return {
        data: processedLines,
        totalLinesInFile: totalLines,
        wasLimited: totalLines > maxLines
      };
    }

    // Escape HTML for safe display
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Show/hide elements
    function showElement(id) {
      document.getElementById(id).classList.remove('hidden');
    }

    function hideElement(id) {
      document.getElementById(id).classList.add('hidden');
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      showElement('error');
    }

    function hideError() {
      hideElement('error');
    }

    // Load dataset from file with streaming approach for large files
    function loadDataset() {
      hideError();
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      
      if (!file) {
        showError('Please select a JSONL file.');
        return;
      }
      
      // For very large files (>50MB), use streaming approach
      if (file.size > 50 * 1024 * 1024) {
        loadDatasetStreaming(file);
      } else {
        loadDatasetNormal(file);
      }
    }
    
    // Normal loading for smaller files
    function loadDatasetNormal(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          // Use chunked parsing with 1000 row limit
          const parseResult = parseJSONL(e.target.result, 1000);
          
          if (!parseResult.data.length) {
            showError('File is empty or contains no valid JSON lines.');
            return;
          }
          
          totalRowsInFile = parseResult.totalLinesInFile;
          allData = parseResult.data;
          filteredData = parseResult.data;
          currentIndex = 0;
          
          // Show notification if data was truncated
          if (parseResult.wasLimited) {
            showError(`Dataset contains ${parseResult.totalLinesInFile.toLocaleString()} rows. Showing top 1,000 rows to prevent memory issues.`);
            // Change error styling to be more informational
            const errorDiv = document.getElementById('error');
            errorDiv.style.color = '#ff9800';
            errorDiv.style.background = '#fff3e0';
          }
          
          updateStats();
          updateSearch();
          updateDisplay();
          
          showElement('statsSection');
          showElement('searchSection');
          showElement('navigationInfo');
          
        } catch (err) {
          showError('Error reading file: ' + err.message);
        }
      };
      
      reader.readAsText(file);
    }
    
    // Streaming approach for large files
    function loadDatasetStreaming(file) {
      const chunkSize = 1024 * 1024; // 1MB chunks
      let offset = 0;
      let buffer = '';
      let linesProcessed = 0;
      let totalLines = 0;
      const maxLines = 1000;
      const parsedData = [];
      
      function readChunk() {
        const slice = file.slice(offset, offset + chunkSize);
        const reader = new FileReader();
        
        reader.onload = function(e) {
          buffer += e.target.result;
          const lines = buffer.split(/\r?\n/);
          
          // Keep the last incomplete line in buffer
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            totalLines++;
            
            if (linesProcessed < maxLines) {
              const trimmed = line.trim();
              if (trimmed && !trimmed.startsWith('//')) {
                try {
                  const parsed = JSON.parse(trimmed);
                  if (parsed) {
                    parsedData.push(parsed);
                    linesProcessed++;
                  }
                } catch (e) {
                  // Skip invalid JSON lines
                }
              }
            }
          }
          
          offset += chunkSize;
          
          // Continue reading if we haven't reached max lines and there's more file
          if (linesProcessed < maxLines && offset < file.size) {
            readChunk();
          } else {
            // Finished reading or reached limit
            finishStreamingLoad();
          }
        };
        
        reader.onerror = function() {
          showError('Error reading file chunk.');
        };
        
        reader.readAsText(slice);
      }
      
      function finishStreamingLoad() {
        // Process any remaining data in buffer
        if (buffer.trim() && linesProcessed < maxLines) {
          totalLines++;
          try {
            const parsed = JSON.parse(buffer.trim());
            if (parsed) {
              parsedData.push(parsed);
              linesProcessed++;
            }
          } catch (e) {
            // Skip invalid JSON
          }
        }
        
        if (!parsedData.length) {
          showError('File is empty or contains no valid JSON lines.');
          return;
        }
        
        totalRowsInFile = totalLines;
        allData = parsedData;
        filteredData = parsedData;
        currentIndex = 0;
        
        // Show notification about streaming and limitation
        const wasLimited = linesProcessed >= maxLines || totalLines > maxLines;
        if (wasLimited) {
          showError(`Large file detected (${(file.size / (1024*1024)).toFixed(1)}MB). Loaded first 1,000 rows of ~${totalLines.toLocaleString()} total rows.`);
          const errorDiv = document.getElementById('error');
          errorDiv.style.color = '#ff9800';
          errorDiv.style.background = '#fff3e0';
        }
        
        updateStats();
        updateSearch();
        updateDisplay();
        
        showElement('statsSection');
        showElement('searchSection');
        showElement('navigationInfo');
      }
      
      // Start streaming
      readChunk();
    }

    // Update statistics
    function updateStats() {
      const stats = allData.reduce((acc, task) => {
        const components = extractFIMComponents(task.content || '');
        const qualityScores = extractQualityScores(task);
        
        acc.totalPrefix += components.prefix.length;
        acc.totalMiddle += components.middle.length;
        acc.totalSuffix += components.suffix.length;
        acc.ratios.push(components.prefix.length > 0 ? components.middle.length / components.prefix.length : 0);
        
        // Collect quality scores for averaging
        if (qualityScores.context !== undefined) acc.contextScores.push(qualityScores.context);
        if (qualityScores.middle !== undefined) acc.middleScores.push(qualityScores.middle);
        if (qualityScores.length !== undefined) acc.lengthScores.push(qualityScores.length);
        if (qualityScores.comprehensive !== undefined) acc.comprehensiveScores.push(qualityScores.comprehensive);
        
        return acc;
      }, { 
        totalPrefix: 0, totalMiddle: 0, totalSuffix: 0, ratios: [],
        contextScores: [], middleScores: [], lengthScores: [], comprehensiveScores: []
      });
      
      const avgPrefix = (stats.totalPrefix / allData.length).toFixed(1);
      const avgMiddle = (stats.totalMiddle / allData.length).toFixed(1);
      const avgSuffix = (stats.totalSuffix / allData.length).toFixed(1);
      const avgRatio = (stats.ratios.reduce((a, b) => a + b, 0) / stats.ratios.length).toFixed(3);
      
      // Calculate average quality scores
      const avgContextScore = stats.contextScores.length > 0 ? 
        (stats.contextScores.reduce((a, b) => a + b, 0) / stats.contextScores.length).toFixed(3) : 'N/A';
      const avgComprehensiveScore = stats.comprehensiveScores.length > 0 ? 
        (stats.comprehensiveScores.reduce((a, b) => a + b, 0) / stats.comprehensiveScores.length).toFixed(3) : 'N/A';
      
      const displayLabel = totalRowsInFile > 1000 ? 
        `Showing Tasks (1K of ${(totalRowsInFile/1000).toFixed(1)}K)` : 
        'Total Tasks';
        
      let statsHTML = `
        <div class="stat-item">
          <div class="stat-value">${allData.length.toLocaleString()}</div>
          <div class="stat-label">${displayLabel}</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${avgPrefix}</div>
          <div class="stat-label">Avg Prefix Length</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${avgMiddle}</div>
          <div class="stat-label">Avg Middle Length</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${avgSuffix}</div>
          <div class="stat-label">Avg Suffix Length</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">${avgRatio}</div>
          <div class="stat-label">Avg M/P Ratio</div>
        </div>
      `;
      
      // Add quality score statistics if available
      if (stats.contextScores.length > 0) {
        statsHTML += `
          <div class="stat-item">
            <div class="stat-value">${avgContextScore}</div>
            <div class="stat-label">Avg Context Quality</div>
          </div>
        `;
      }
      
      if (stats.comprehensiveScores.length > 0) {
        statsHTML += `
          <div class="stat-item">
            <div class="stat-value">${avgComprehensiveScore}</div>
            <div class="stat-label">Avg Overall Quality</div>
          </div>
        `;
      }
      
      document.getElementById('statsSection').innerHTML = statsHTML;
    }

    // Update search functionality
    function updateSearch() {
      const searchInput = document.getElementById('searchInput');
      searchInput.oninput = function() {
        const term = this.value.trim();
        currentIndex = 0;
        
        if (!term) {
          filteredData = allData;
          document.getElementById('searchResults').textContent = '';
        } else {
          filteredData = allData.filter((task, index) => {
            const components = extractFIMComponents(task.content || '');
            const qualityScores = extractQualityScores(task);
            
            // Include quality scores in search
            const qualityText = [
              qualityScores.comprehensive ? `quality:${qualityScores.comprehensive.toFixed(3)}` : '',
              qualityScores.context ? `context:${qualityScores.context.toFixed(3)}` : '',
              qualityScores.middle ? `middle:${qualityScores.middle.toFixed(3)}` : '',
              qualityScores.length ? `length:${qualityScores.length.toFixed(3)}` : '',
              qualityScores.ratio ? `ratio:${qualityScores.ratio.toFixed(3)}` : ''
            ].join(' ');
            
            const searchIn = [
              components.prefix,
              components.middle,
              components.suffix,
              task.output || '',
              (index + 1).toString(),
              qualityText
            ].join(' ').toLowerCase();
            
            return searchIn.includes(term.toLowerCase());
          });
          
          document.getElementById('searchResults').textContent = 
            `Found ${filteredData.length} task(s) matching "${term}"`;
        }
        
        updateDisplay();
      };
    }

    // Update the main display
    function updateDisplay() {
      if (filteredData.length === 0) {
        hideElement('fimCard');
        showElement('noResults');
        return;
      }
      
      hideElement('noResults');
      showElement('fimCard');
      
      const task = filteredData[currentIndex];
      const components = extractFIMComponents(task.content || '');
      const qualityScores = extractQualityScores(task);
      
      // Debug logging
      console.log('Displaying task:', currentIndex + 1);
      console.log('Components:', components);
      console.log('Quality scores:', qualityScores);
      
      // Build quality scores display
      let qualityHTML = '';
      const qualityItems = [];
      
      if (qualityScores.comprehensive !== undefined) {
        qualityItems.push(formatQualityScore(qualityScores.comprehensive, 'Overall Quality'));
      }
      if (qualityScores.context !== undefined) {
        qualityItems.push(formatQualityScore(qualityScores.context, 'Context Quality'));
      }
      if (qualityScores.middle !== undefined) {
        qualityItems.push(formatQualityScore(qualityScores.middle, 'Middle Quality'));
      }
      if (qualityScores.length !== undefined) {
        qualityItems.push(formatQualityScore(qualityScores.length, 'Length Quality'));
      }
      
      // Add ratio and length metrics
      if (qualityScores.ratio !== undefined) {
        qualityItems.push(`
          <div class="quality-score">
            <span class="quality-score-label">M/P Ratio:</span>
            <span class="quality-score-value">${qualityScores.ratio.toFixed(3)}</span>
          </div>
        `);
      }
      
      // Add prefix and middle lengths if available
      if (qualityScores.prefixLength !== undefined) {
        qualityItems.push(`
          <div class="quality-score">
            <span class="quality-score-label">Prefix Length:</span>
            <span class="quality-score-value">${qualityScores.prefixLength}</span>
          </div>
        `);
      }
      
      if (qualityScores.middleLength !== undefined) {
        qualityItems.push(`
          <div class="quality-score">
            <span class="quality-score-label">Middle Length:</span>
            <span class="quality-score-value">${qualityScores.middleLength}</span>
          </div>
        `);
      }
      
      // Add quality tier if available
      if (qualityScores.tier !== undefined) {
        const tierLevel = qualityScores.tier === 'high' ? 'high' : qualityScores.tier === 'medium' ? 'medium' : 'low';
        qualityItems.push(`
          <div class="quality-score ${tierLevel}">
            <span class="quality-score-label">Quality Tier:</span>
            <span class="quality-score-value">${qualityScores.tier.toUpperCase()}</span>
          </div>
        `);
      }
      
      if (qualityItems.length > 0) {
        qualityHTML = `
          <div class="quality-section">
            <div class="fim-section-title" style="border-left-color: #17a2b8;">üìä Quality Metrics</div>
            <div class="quality-scores">
              ${qualityItems.filter(item => item !== null).join('')}
            </div>
          </div>
        `;
      }
      
      // Get overall quality badge for header
      let qualityBadge = '';
      if (qualityScores.comprehensive !== undefined) {
        const level = getQualityLevel(qualityScores.comprehensive);
        const levelText = level === 'high' ? 'High Quality' : level === 'medium' ? 'Medium Quality' : 'Low Quality';
        qualityBadge = `<span class="quality-badge ${level}">${levelText}</span>`;
      }
      
      document.getElementById('fimCard').innerHTML = `
        <div class="fim-card">
          <div class="fim-header">
            <span>Task #${currentIndex + 1}${qualityBadge}</span>
            <div class="navigation">
              <button onclick="navigate(-1)" ${currentIndex === 0 ? 'disabled' : ''}>
                ‚Üê Previous
              </button>
              <span class="page-info">${currentIndex + 1} of ${filteredData.length}</span>
              <button onclick="navigate(1)" ${currentIndex === filteredData.length - 1 ? 'disabled' : ''}>
                Next ‚Üí
              </button>
            </div>
          </div>
          
          ${qualityHTML}
          
          <div class="fim-section">
            <div class="fim-section-title fim-prefix">üü¢ FIM Prefix (${components.prefix.length} chars)</div>
            <div class="fim-content">${escapeHtml(components.prefix) || '(empty)'}</div>
          </div>
          
          <div class="fim-section">
            <div class="fim-section-title fim-middle">üü† FIM Middle (${components.middle.length} chars)</div>
            <div class="fim-content">${escapeHtml(components.middle) || '(empty)'}</div>
          </div>
          
          <div class="fim-section">
            <div class="fim-section-title fim-suffix">üü£ FIM Suffix (${components.suffix.length} chars)</div>
            <div class="fim-content">${escapeHtml(components.suffix) || '(empty)'}</div>
          </div>
          
          ${task.output ? `
            <div class="fim-section">
              <div class="fim-section-title" style="border-left-color: #2196F3;">üîµ Output</div>
              <div class="fim-content">${escapeHtml(task.output)}</div>
            </div>
          ` : ''}
        </div>
      `;
    }

    // Navigation function
    function navigate(direction) {
      const newIndex = currentIndex + direction;
      if (newIndex >= 0 && newIndex < filteredData.length) {
        currentIndex = newIndex;
        updateDisplay();
      }
    }

    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
      if (e.key === 'ArrowLeft' && currentIndex > 0) {
        navigate(-1);
      } else if (e.key === 'ArrowRight' && currentIndex < filteredData.length - 1) {
        navigate(1);
      }
    });

    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      console.log('FIM Dataset Viewer loaded successfully');
    });
  </script>
</body>
</html>